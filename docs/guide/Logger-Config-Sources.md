# Source Definitions {#LoggerConfigSources}
[TOC]

Each source is configured in its own section, starting with a section tag in square brackets (e.g. `[Bus01]`, `[DW]`) and followed by the source specific configuration values.
The name given in the tag is used when printing log messages to identify the source responsible for them and will be used as the source name unless overridden by a `name` option.

## Generic configuration options
Common to almost all supported sources are the options `name`, `type`, and `sourcenum`.
Of these, `type` is mandatory.

~~~{.py}
[Bus01]           # Section tag
name = Marine     # Source name
type = n2k        # Source type (mandatory)
sourcenum = 0x61  # Source number
~~~

The `type` options identifies which of the supported source types are being configured by this block.
Blocks without a valid `type` specified will generate an error.
See [supported sources](@ref SupportedSources) for details of valid type options.

The `name` option controls the reported source name used in the channel information file, which is then available for subsequent processing and data conversion software.
If not provided, it defaults to the section tag.
The name is arbitrary information and is not used by the logging software itself.

The `sourcenum` option controls the ID number used to identify messages from this source.
There can be only one source active with a given number for a particular configuration.

If no `sourcenum` option is present, a suitable value will be configured automatically.
Numbers can be specified in decimal or, as shown in the example above, as hexadecimal digits prefixed with `0x`.

## Supported Sources and Devices {#SupportedSources}
Each source is defined in its own section, with the tag, name, and source number specified as described above.
The `type` option is required before the source specific options will be processed, and unknown options are generally ignored.

Each of the sections below will show a small example configuration section, then provide more detailed explanation of all valid configuration options for that source type. In the configuration examples, "#" marks an explanatory comment that should be omitted when creating your own configuration files.

### GPS Source Options {#LoggerSource-GPS}
**type = GPS**

The current GPS code is limited to supporting uBlox based GPS devices attached via a serial or USB connection.

~~~{.py}
[GPS01]
type = GPS          # Mandatory
port = /dev/ttyUSB1 # Path to serial device
initialbaud = 9600  # Initial baud rate after reset
baud = 115200       # Baud rate for general usage
dumpall = false     # Include all output messages
~~~

- `port`: Serial port name or path. See also [device names](@ref devicenames).
- `initialbaud`: Initial baud rate to use. Some uBlox devices start at a slower rate and need to be reconfigured to a more suitable rate for general data transfer, so set the initial power-up/reset baud rate here.
- `baud`: General baud rate to use after initial configuration.
- `dumpall`: Enable unfiltered output, passing (and recording) additional messages in the output file. Otherwise, only parsed messages are saved, reducing the size of the recorded data files.

### MP Source Options {#LoggerSource-MP}
**type = MP** or **type = SL**

This source type is for use with devices that directly output msgpack formatted data as described in the [Logger technical details](@ref LoggerTechDetails) page.

~~~{.py}
[MP02]
type = MP           # Mandatory
port = /dev/ttyACM0 # Path to serial device
baud = 115200       # Baud rate
~~~

- `port`: Serial port name or path. See also [device names](@ref devicenames).
- `baud`: General baud rate to use after initial configuration.

Note that the general `sourcenum` and `name` parameters are ignored here, as they will be provided directly by the connected device.

The source tag (`MP02` in this example) will be used in any log messages generated by the logging software.

### I2C Source Options {#LoggerSource-I2C}
**type = I2C**
~~~{.py}
[AutomationHat]
type = I2C                  # Mandatory
bus = /dev/i2c-1            # Path to I2C bus
ads1015=0x48:4:0.007:0.002  # Device specific configuration
frequency = 2               # Bus polling frequency
~~~

There are two general parameters that need to be provided in order to record data from I2C connected sensors.

- `bus`: Path to the I2C bus / device. See [device names](@ref devicenames) for some generic considerations here
- `frequency`: Number of sensor readings to request per second.

Unlike most other data sources, I2C readings must be requested by the logging software rather than being recorded on arrival.
The frequency set here is a single value per bus, so must be supported by all sensors in use.

After defining the bus name and polling frequency, each individual sensor must be configured.
In general, each sensor definition will need to provide a sensor type, I2C address and the (base) channel ID.

The sensor type is provided by the configuration option name (which may be present more than once), with the I2C address and base message ID provided in hex, separated by a colon. In the example configuration, an ADS1015 sensor is being configured at address 72 (0x48) and the first value provided by that sensor will be at channel 4. If the base message ID is missing, a default will be substituted. Mixing automatic and manual allocation of base message ID may lead to conflicts and is not recommended.

#### INA219 Voltage and current monitor (ina219) {#LoggerSource-INA219}
The INA219 chip measures the current being supplied to a circuit through a shunt resistor.
Each chip provides three measurements, using three sequential channel numbers:
* Channel `n`: Bus voltage (supply voltage to the positive side of the shunt resistor) [Volts]
* Channel `n+1`: Shunt voltage (voltage drop across the shunt resistor) [millivolts]
* Channel `n+2`: Current flowing to the load (calculated from the voltage drop across the shunt resistor) [Amps]

Multiple chips can be connected to a single I2C bus using different addresses, and the channel numbers can optionally be set in the configuration file.

To read from an INA219 chip, add the following line to the source definition:
~~~{.py}
# ina219 = address[:channel]
ina219 = 0x32    # Device at address 0x32, automatically numbering channels
ina219 = 0x33:7  # Device at address 0x33, using channels 7, 8, and 9

~~~

Add additional lines for each chip connected to that I2C bus.

As an example, the [Waveshare Current/Power monitor hat](https://www.waveshare.com/wiki/Current/Power_Monitor_HAT) could be configured as shown:

~~~{.py}
[PM]
type = I2C
bus = /dev/i2c-1
frequency = 2
ina219 = 0x40:4
ina219 = 0x41:7
ina219 = 0x42:10
ina219 = 0x43:13
~~~

#### ADS1015 ADC (ads1015) {#LoggerSource-ADS1015}
The ADS101x series of analog-digital conversion chips measure analog voltage levels and output that information digitally over I2C.
These chips are used in several ADC implementations that can be connected to single board computers (such as a Raspberry Pi) or to microcontrollers (including the Arduino family of devices).

The current implementation assumes that the chip used is an ADS1015 device, which provides 4 inputs.
These are assigned channel numbers `n` to `n+3`, where `n` is the base channel ID.
Adding an ADS1015 chip as a source requires its I2C address, and optionally the base channel number can be provided as described above for INA219 chips.
~~~{.py}
ads1015 = 0x48
ads1015 = 0x47:5
~~~

Additionally, scaling, offset, and limit values can be provided as colon separated values in order.
In this case, the base channel ID must also be supplied.
Scaling is applied linearly to each channel, multiplying the original value by the scaling factor and then adding the offset.
Values that then lie outside any configured limits will be replaced with NaN values.

The default values are a scale of 1.0, offset of 0 and limits of \f$-\infty,+\infty\f$.

~~~{.py}
# ads1015 = addr:base:scale:offset:min:max
ads1015 = 0x47:5:3.22:-17.75:-15:+30
ads1015 = 0x48:9:1.0:-5
~~~

In the first of these examples, data from the chip at address 0x47 would be multiplied by 3.22 and offset by -17.75.
Note that this would be applied to all four channels.
The resulting values would be replaced with NaN if the results are below -15 or above +30.

### NMEA Source Options
#### NMEA 0183
**type = NMEA**

This source type allows messages broadcast in NMEA0183 format to be captured, with some messages interpreted for more convenient use and analysis.
The connected device can either be a single serial device that outputs messages in this format, or a serial interface to an NMEA0183 bus.

~~~{.py}
[NM03]
type = NMEA         # Mandatory
port = /dev/ttyUSB3 # Path to serial device
baud = 115200       # Baud rate
~~~

Currently, the following messages are parsed into their own channels:

| Talker | Message | Description | Channel Number |
| :----: | :-----: | :---------- | :------------: |
|   II   |   ZDA   | Date / Time |       4        |

All other messages are stored in channel 3 for later extraction and analysis.

#### NMEA 2000
**type = N2K**

The newer NMEA 2000 format is a binary encoded message format, similar to CAN messages in the automotive sector.
Support for this communications format is currently limited to the Actisense NGT-1 interface, which receives encoded messages from an NMEA 2000 bus and rebroadcasts them via serial or USB to a connected computer.

~~~{.py}
[N2K]
type = n2k          # Mandatory
port = /dev/ttyUSB6 # Path to serial device
baud = 115200       # Baud rate
~~~

- `port`: Serial port name or path. See also [device names](@ref devicenames).
- `baud`: Serial data baud rate - must match configuration on the Actisense device

The `sourcenum` and `name` parameters should also be provided to make later analysis more consistent.

Currently, the following messages are parsed into their own channels:

|   PGN   |     Description     |   Channel Number  |
| :-----: | :------------------ | :---------------: |
|  129025 | Position (Lat/Lon)  | 4 (Lat) / 5 (Lon) |

All other messages are stored in channel 3 for later extraction and analysis.

### Datawell Source Options

**type = DW**

This source type allows data to be recorded from a Datawell Waverider via an RF receiver connected to the local network.

~~~{.py}
[BoB]
type = DW             # Mandatory
host = "172.16.104.1" # Receiver IP address
timeout = 3600        # Max. seconds to wait for data
raw = true            # Record raw messages received
spectrum = false      # Parse spectral data
~~~

- `host` - IP address or DNS name for the RF receiver. The port number is fixed at 1180
- `timeout` - Consider the connection lost if no data is received after this period (in seconds).
- `raw` - Record raw message data from the receiver in addition to parsed data. Recommended.
- `spectrum` - Parse spectral information into data file.
  - This is not recommended, as much of the structure of the spectral data is not preserved in the output file in this format.
  - It is recommended to record raw messages and then extract the data for analysis later.

This source generates several channels of data, the full details of which are documented in the source code for dw_channels().

| Description                  | Channel Number |
| :----------------------------| :------------: |
| Raw Data                     |        3       |
| Signal                       |        4       |
| Displacement N               |        5       |
| Displacement W               |        6       |
| Displacement V               |        7       |
| Latitude                     |        8       |
| Longitude                    |        9       |
| Orientation                  |       10       |
| Inclination                  |       11       |
| GPS Status                   |       12       |
| RMS Height                   |       13       |
| Reference Temperature        |       14       |
| Water Temperature            |       15       |
| Weeks of battery remaining   |       16       |
| Spectrum: FrequencyBin       |       17       |
| Spectrum: Direction          |       18       |
| Spectrum: Spread             |       19       |
| Spectrum: m2                 |       20       |
| Spectrum: n2                 |       21       |
| Spectrum: RPSD               |       22       |
| Spectrum: K                  |       23       |

Channels 17-23 are only output if the `spectrum` option is enabled.

\todo Timer configuration
\todo Network source configuration
\todo Generic serial source configuration
\todo MQTT configuration (generic / victron)

## Example Configuration

~~~{.py}
stateFile = "testData/logger.state"
saveState = True
prefix = "testData/Log-"
verbose = 3
frequency = 10

[GPS01]
baud = 19200
sourcenum = 5
type = GPS
# N.B. Can't assume this will always be the same device
# Consider using udev rules to give devices permanent names
port = "/dev/ttyUSB0"
~~~

## Device Names {#devicenames}
Most external devices are represented on a Linux machine by named files in the `/dev` directory (e.g. `/dev/ttyUSB0` for a USB serial adapter, `/dev/i2c-1` for an I2C interface).
The names of many of these files are dynamic, and are assigned when devices are connected or when they are discovered during start up.
This means that the numbered suffix may change if a device is unplugged and reconnected, and may change when the computer is rebooted.
This is a particular problem for USB serial devices that may be used as data sources (i.e. anything starting `/dev/tty`).

Rather than use the short dynamically assigned names in configuration files, a stable name should be used.
On Debian (and therefore Raspberry Pi OS) based devices, stable names can be found in `/dev/serial/by-id/` with file names based on the make, model, and serial number of the serial interface (which may differ from the equipment serial number).

As a modified example from a real system:
~~~
tom@local:~ $ ls -l /dev/serial/by-id/
lrwxrwxrwx 1 root root 13 May 25 13:29 usb-Actisense_NGT-1 -> ../../ttyUSB0
lrwxrwxrwx 1 root root 13 May 25 13:29 usb-Silicon_Labs__LPMSCU30006 -> ../../ttyUSB1
lrwxrwxrwx 1 root root 13 May 25 20:44 usb-u-blox_AG_-_GPS_GNSS_Receiver -> ../../ttyACM1
~~~

The short names at the time this list was generated are shown at the end of the line.

Another option is to write udev rules to create custom names for each connected device.
How to write these rules is outside the scope of this documentation.

## Further reading
* Up: [Logger configuration](@ref LoggerConfig)
* Prev: [Logger core options](@ref LoggerConfigCore)
