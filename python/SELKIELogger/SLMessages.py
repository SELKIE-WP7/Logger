import msgpack
import logging
from warnings import warn


## @brief Python representation of a logged message
class SLMessage:
    """
    Represent messages stored by the Logger program and generated by devices
    with compatible firmware.

    Messages are 4 element MessagePacked arrays, with the first element a
    constant 0x55, second and third elements identifying the source and message
    IDs and the final element containing the data for that message.
    """

    __slots__ = ["SourceID", "ChannelID", "Data"]

    def __init__(self, sourceID, channelID, data):
        """!
        Create message with specified source, channel and data.

        Note that the C library and utilities only support a limited range of
        types within these messages. Check the library documentation for
        details.
        
        @sa library/base/sources.h
        """
        try:
            assert (0 <= sourceID  and sourceID < 128)
            assert (0 <= channelID and channelID < 128)
        except:
            print(f"Source: {sourceID}, Channel: {channelID}, Data: {data}")
            raise

        self.SourceID = sourceID
        self.ChannelID = channelID
        self.Data = data

    @classmethod
    def unpack(cl, data):
        """Unpack raw messagepack bytes or list into SLMessage"""
        if isinstance(data, bytes):
            data = msgpack.unpackb(data)
        if not isinstance(data, list) or len(data) != 4:
            raise ValueError("Bad message")
        assert (data[0] == 0x55)
        return cl(data[1], data[2], data[3])

    def pack(self):
        """Return packed binary representation of message"""
        return msgpack.packb([0x55, self.SourceID, self.ChannelID, self.Data])

    def __repr__(self):
        """Represent class as packed binary data"""
        return self.pack()

    def __str__(self):
        """Return printable representation of message"""
        return f"{self.SourceID:02x}\t{self.ChannelID:02x}\t{str(self.Data)}"

class SLMessageSource:
    """!
    Software message source

    Provide a framework for creating valid messages from within Python code.
    Although this class enforces channel names and provides support for the
    standard messages (except timestamps), no restriction is placed on the data
    types used in data messages. See separate documentation for the library to
    check compatibility.

    @sa library/base/sources.h
    """
    def __init__(self, sourceID, name="PythonDL", dataChannels=1, dataChannelNames=None):
        """Any valid source must have a source ID, name and a list of named data channels"""
        self.SourceID = int(sourceID)
        self.Name = str(name)
        self.ChannelMap = ["Name", "Channels", "Timestamp"]

        if self.SourceID > 127 or self.SourceID <= 0:
            raise ValueError("Invalid Source ID")

        if dataChannelNames is None:
            dataChannelNames = [f"Data{x+1}" for x in range(dataChannels)]

        if len(dataChannelNames) != dataChannels:
            raise ValueError(f"Inconsistent number of channels specified: Expected {dataChannels}, got {len(dataChannels)}")

        if len(dataChannelNames) > 0:
            self.ChannelMap.extend(dataChannelNames)

    def IDMessage(self):
        """Return source name message (Channel 0)"""
        return SLMessage(self.SourceID, 0, self.Name)

    def ChannelsMessage(self):
        """Generate channel name map message (Channel 1)"""
        return SLMessage(self.SourceID, 1, self.ChannelMap)

    def InfoMessage(self, message):
        """Return INFO level log message"""
        return SLMessage(self.SourceID, 125, str(message))

    def WarningMessage(self, message):
        """Return WARNING level log message"""
        return SLMessage(self.SourceID, 126, str(message))

    def ErrorMessage(self, message):
        """Return ERROR level log message"""
        return SLMessage(self.SourceID, 127, str(message))

    def TimestampMessage(self):
        """
        Placeholder for timestamp message (Channel 2)

        Sources should provide a timestamp periodically to allow messages
        generated at a particular time to be grouped.

        Not implemented here
        """
        raise NotImplemented

    def DataMessage(self, channelID, data):
        """Return message representing data from this source"""
        assert channelID < len(self.ChannelMap)
        return SLMessage(self.SourceID, channelID, data)


class SLMessageSink:
    """!
    Parse incoming messages.

    Maintains an internal mapping of channel and source names to provide prettier output.

    Expects data to be provided one message at a time to .Process(), and will
    return data as a dict, printable string or as an SLMessage().
    """
    def __init__(self, msglogger=None):
        """
        Initialise message sink

        Optionally accepts a logging object for any error, warning, or
        information messages encountered in the source data.
        """
        self.Sources = dict()

        self._log = logging.getLogger(__name__)
        self._msglog = msglogger

        if self._msglog is None:
            warn("No message logger specified")
            self._msglog = logging.getLogger(f"{__name__}.msg")

    def SourceName(self, source):
        """Update the map of known source names"""
        if source in self.Sources:
            return self.Sources[source]['name']
        else:
            return f"[{source:02x}]"

    def ChannelName(self, source, channel):
        """Update the map of known channel names"""
        if not isinstance(channel, int):
            self._log.warning(f"Non-integer channel number requested: {channel}")
            return f"[Invalid:{channel}]"
        if source in self.Sources:
            if channel < (len(self.Sources[source]['channels'])):
                return self.Sources[source]['channels'][channel]
            elif channel == 125:
                return "Information"
            elif channel == 126:
                return "Warning"
            elif channel == 127:
                return "Error"
            else:
                return f"[{channel:02x}]"

    def FormatMessage(self, msg):
        """Pretty print a message"""
        return f"{self.SourceName(msg.SourceID)}\t{self.ChannelName(msg.SourceID, msg.ChannelID)}\t{msg.Data}"

    def Process(self, message, output="dict", allMessages=False):
        """ Process an incoming message

        Accepts a SLMessage or bytes that can be unpacked.
        If a valid message is decoded, internal data structures are updated to
        provide channel and source names for message formatting and tracking of
        the last timestamp seen from each source. Any data messages are
        returned as a string or as a dictionary.
        """
        if output not in [None, "string", "dict", "raw"]:
            raise ValueError("Bad output type")

        if not isinstance(message, SLMessage):
            try:
                message = SLMessage.unpack(message)
            except ValueError:
                self._log.info("Bad message encountered, skipping")
                self._log.debug(message)
                return

        if not message.SourceID in self.Sources:
            self.Sources[message.SourceID] = {'name': f'[{message.SourceID:02x}]', 'channels': ["Name", "Channels", "Timestamp"], 'lastTimestamp': 0}

        suppressOutput = False
        if message.ChannelID == 0:
            self._log.debug(f"New name for {self.SourceName(message.SourceID)}: {message.Data}")
            self.Sources[message.SourceID]['name'] = message.Data
            suppressOutput = True
        elif message.ChannelID == 1:
            self._log.debug(f"New channels for {self.SourceName(message.SourceID)}: {message.Data}")
            self.Sources[message.SourceID]['channels'] = message.Data
            suppressOutput = True
        elif message.ChannelID == 2:
            self._log.debug(f"New update time for {self.SourceName(message.SourceID)}: {message.Data}")
            self.Sources[message.SourceID]['lastTimestamp'] = message.Data
            suppressOutput = True
        elif message.ChannelID == 125:
            self._msglog.info(self.FormatMessage(message))
            suppressOutput = True
        elif message.ChannelID == 126:
            self._msglog.warning(self.FormatMessage(message))
            suppressOutput = True
        elif message.ChannelID == 127:
            self._msglog.error(self.FormatMessage(message))
            suppressOutput = True

        if allMessages or (not suppressOutput):
            if output == "dict":
                return {
                        'sourceID': message.SourceID, 'sourceName': self.SourceName(message.SourceID),
                        'channelID': message.ChannelID, 'channelName': self.ChannelName(message.SourceID, message.ChannelID),
                        'data': message.Data
                        }
            elif output == "string":
                return self.FormatMessage(message)
            elif output == "raw":
                return message
            else:
                return
